# Terraform Associate Certification

## What is Terraform?

Terraform is an open-source infrastructure as code software tool created by HashiCorp. Users define and provide data center infrastructure using a declarative configuration language known as HashiCorp Configuration Language, or optionally JSON.

## How to install Terraform

### Linux

```bash
wget https://releases.hashicorp.com/terraform/0.12.24/terraform_0.12.24_linux_amd64.zip
unzip terraform_0.12.24_linux_amd64.zip
sudo mv terraform /usr/local/bin/
terraform version
```

### Windows

```powershell
Invoke-WebRequest -Uri https://releases.hashicorp.com/terraform/0.12.24/terraform_0.12.24_windows_amd64.zip -OutFile terraform_0.12.24_windows_amd64.zip
mkdir C:\Program Files\terraform
Expand-Archive terraform_0.12.24_windows_amd64.zip -DestinationPath C:\Program Files\terraform
$env:Path += ";C:\Program Files\terraform"
terraform version
```

### Mac

```bash
brew install terraform
terraform version
```

## What is HashiCorp Configuration Language(HCL)?

HCL is a configuration language created by HashiCorp. It is designed to be easy to read, write, and maintain. It is used in HashiCorp products to configure various elements such as services, resources, and provisioning.

It consists of two syntaxes: JSON and HCL. HCL is a superset of JSON, which means that every JSON file is also a valid HCL file. HCL is more human-readable than JSON, and it supports comments.

It conists of two things:

- blocks : blocks are containers for other content and they have a type, label, and a set of arguments and nested blocks.
- arguments : arguments assign a value to a name. Arguments can appear only within blocks.

### Example

```hcl
resource "aws_instance" "example" {
  ami           = "ami-2757f631"
  instance_type = "t2.micro"
}
```

in the above example, `resource` is a block, `aws_instance` is a Resource type, `example` is a Resource Name, `ami` and `instance_type` are arguments, and `"ami-2757f631"` and `"t2.micro"` are argument values.

## Terraform Workflow

Terraform workflow consists of 4 steps:

1. Write a Terraform configuration file
2. Initialize a working directory containing Terraform configuration files
3. Plan changes
4. Apply changes

### Write a Terraform configuration file

Terraform configuration files are written in HashiCorp Configuration Language(HCL) with a `.tf` extension.

### Initialize a working directory containing Terraform configuration files

```bash
    terraform init
```

This command is used to initialize a working directory containing Terraform configuration files. This is the first command that should be run after writing a new Terraform configuration or cloning an existing one from version control. It is safe to run this command multiple times.

### Plan changes

```bash
    terraform plan
```

This command is used to create an execution plan. Terraform performs a refresh, unless explicitly disabled, and then determines what actions are necessary to achieve the desired state specified in the configuration files.

### Apply changes

```bash
    terraform apply
```

This command is used to apply the changes required to reach the desired state of the configuration, or the pre-determined set of actions generated by a terraform plan execution plan.

## How to destroy resources

```bash
    terraform destroy
```

This command is used to destroy the Terraform-managed infrastructure.

## What is Terraform Provider?

A provider is responsible for understanding API interactions and exposing resources. Providers are a mechanism for Terraform to make API calls to the service API.

There are 3 types of providers:

- Official Providers
- Community Providers
- Partner Providers

### Official Providers

Official providers are maintained by HashiCorp and are available on the [Terraform Registry](https://registry.terraform.io/browse/providers).

### Community Providers

Community providers are maintained by the community and are available on the [Terraform Registry](https://registry.terraform.io/browse/providers).

### Partner Providers

Partner providers are maintained by partners and are available on the [Terraform Registry](https://registry.terraform.io/browse/providers).

### Where does the terraform provider get installed?

Terraform providers are installed in the `~/.terraform.d/plugins` directory.

### How to use multiple providers in a single configuration?

```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 2.0"
    }
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 2.0"
    }
  }
}

provider "aws" {
  region = "us-east-1"
}

provider "azurerm" {
  features {}
}

resource "aws_instance" "example" {
  ami           = "ami-2757f631"
  instance_type = "t2.micro"
}

resource "azurerm_resource_group" "example" {
  name     = "example-resources"
  location = "West Europe"
}
```

## What is variable in Terraform?

A variable is a value that can be changed in different environments. It is a way to parameterize your configuration so that it can be used in different environments.

### How to define a variable?

```hcl

variable "name" {
  type        = string
  description = "The name of the person to greet."
  default     = "Terraform"
}
```

### How to use a variable?

```hcl
resource "aws_instance" "example" {
  ami           = "ami-2757f631"
  instance_type = "t2.micro"
  tags = {
    Name = var.name
  }
}
```

### What is varible block?

A variable block is used to define a variable. It consists of 3 parts:

- name
- type
- description

Example:

```hcl

variable "name" {
  type        = string
  description = "The name of the person to greet."
  default     = "Terraform"
}
```

### What is variable type?

A variable type is used to define the type of the variable. It can be one of the following:

- string: A sequence of characters.
- number: A numeric value.
- bool: A boolean value.
- list: A list of values.
- tuple: A fixed-length list of values.
- set: A set of unique values.
- map: A dictionary of key/value pairs.
- object: An arbitrary nested structure.Also classified as a complex type. Consider Class in OOPS.

|Type |Syntax|
|---|---|
|String|"Test"|
|Number|42|
|Boolean|true|
|List|["a", "b", "c"]|
|Tuple|["a", "b", "c"]|
|Set|["a", "b", "c"]|
|Map|{a = "x", b = "y", c = "z"}|
|Object|{a = "x", b = {c = "y"}}|

Object is a complex type. It can be used to define a complex structure.

Example:

```hcl
variable "name" {
  type = object({
    first = string
    last  = string
    food  = list(string)
    Countries = set(string)
    age = number
    Friends = map(string)
  })
    default = {
        first = "John"
        last  = "Doe"
        food  = ["Pizza", "Burger"]
        Countries = ["India", "USA"]
        age = 25
        Friends = {
        "John" = "Doe"
        "Jane" = "Doe"
        }
    }

}
```

Differnce between list and set and tuple:

|List|Set|Tuple|
|---|---|---|
|List is a sequence of values.|Set is a collection of unique values.|Tuple is a fixed-length sequence of values.|
|List is ordered.|Set is unordered.|Tuple is ordered.|
|List is indexed.|Set is not indexed.|Tuple is indexed.|
|List is mutable.|Set is mutable.|Tuple is immutable.|
|List can contain duplicate values.|Set cannot contain duplicate values.|Tuple can contain duplicate values.|

### What if we don't specify a variable default value?

If we don't specify a variable default value, then we have to provide a value for the variable when we run the terraform plan or terraform apply command.

OR

We can also provide a value for the variable in the terraform.tfvars file.Filename should be terraform.tfvars or terraform.tfvars.json or any .auto.tfvars or .auto.tfvars.json file. It will be automatically loaded by Terraform. If you want to use a different file name, then you can use the -var-file option.

Example:

```hcl
name = "John"
age = 25
```

Example:

```hcl
    terraform plan -var-file="somefile.tfvars"
```

OR

We can also pass the variable value as a command-line argument. For example:

```bash
    terraform plan -var 'name="John"' -var 'age=25'
```

OR

We can also use of the environment variables. For example:

```bash
    export TF_VAR_name="John"
    export TF_VAR_age=25
```

### Varible Validation

We can use the validation block to validate the variable value. It can be used to validate the following:

- String length
- String pattern
- Number range
- List length
- Set length
- Tuple length
- Map length
- Object attributes

Example:

```hcl
variable "name" {
  type        = string
  description = "The name of the person to greet."
  default     = "Terraform"
  validation {
    condition     = length(var.name) > 5
    error_message = "The name must be at least 5 characters long."
  }
}
```

### How varible precedence works?

Terraform uses the following precedence order when assigning values to variables:

1. Variables explicitly set using the -var or -var-file options on the command line.
2. Variables set in the terraform.tfvars or any .auto.tfvars or .auto.tfvars.json files.
3. Variables set in the environment variables.
4. Variables defined in the configuration files.

|Order|Option|
|---|---|
|1|-var or -var-file|
|2|terraform.tfvars or any .auto.tfvars or .auto.tfvars.json|
|3|Environment variables|
|4|Configuration files|

## Resource Attribute

A resource attribute is a property of a resource. It is used to define the configuration of a resource. It can be one of the following:

Example:

```hcl
resource "azurerm_resource_group" "example" {
  name     = "example-resources"
  location = "West Europe"
}

resource "azurerm_storage_account" "example" {
  name                     = "examplestorageaccount"
  resource_group_name      = azurerm_resource_group.example.name
  location                 = azurerm_resource_group.example.location
  account_tier             = "Standard"
  account_replication_type = "LRS"
}
```

In the above example, the resource attribute name is used to define the name of the resource. Similarly, we refer resource group name and location in the storage account resource.

## Resource Dependency

A resource dependency is used to define the dependency between resources. It is used to define the order in which the resources should be created. It is defined using the resource name.

There are two types of resource dependency:

- Implicit dependency: It is automatically created by Terraform. It is created when we refer a resource attribute in another resource.
- Explicit dependency: It is created by us. It is created using the depends_on argument.

Example of Explicit dependency:

```hcl

resource "azurerm_resource_group" "example" {
  name     = "example-resources"
  location = "West Europe"
}

resource "azurerm_storage_account" "example" {
  name                     = "examplestorageaccount"
  resource_group_name      = azurerm_resource_group.example.name
  location                 = azurerm_resource_group.example.location
  account_tier             = "Standard"
  account_replication_type = "LRS"
  depends_on = [azurerm_resource_group.example]
}
```

In the above example, we have created an explicit dependency between the resource group and storage account. It means that the storage account will be created after the resource group.

## Output Variable

An output variable is used to display the output of a Terraform configuration. It is defined using the output block.

Example:

```hcl
output "resource_group_name" {
  value = azurerm_resource_group.example.name
}
```

Real world use case of attribute and output variable imagine you have created a resource group and storage account. Now you want to display the name of the resource group and storage account. You can use the output variable to display the name of the resource group and storage account.

### Can we display sensitive information using output variable?

No, we cannot display sensitive information using output variable. It is because the output variable is stored in the state file. If we display sensitive information using output variable, then it will be stored in the state file. It is not a good practice to store sensitive information in the state file.

## Terraform State

Terraform state is used to store the information about the resources that are created by Terraform. It is used to track the state of the resources. It is stored in the state file. It is stored in the JSON format. It is stored in the local file system by default. We can also store it in the remote backend.

### Content of the state file

The state file contains the following information:

- Terraform version
- Configuration
- Resource information
- Resource dependency
- Output variable

### Purpose of the state file

The state file is used to track the state of the resources.

### Terraform state commands

The following are the Terraform state commands:

- terraform state list: It is used to list the resources.
- terraform state show: It is used to show the information about the resource.
- terraform state pull: It is used to pull the state file.
- terraform state push: It is used to push the state file.
- terraform state mv: It is used to move the resource from one state to another state.
- terraform state rm: It is used to remove the resource from the state.
- terraform state replace-provider: It is used to replace the provider.
- terraform state replace-provisioner: It is used to replace the provisioner.

### Terraform Refresh with plan

Terraform refresh is used to update the state file.

How to improve the performance of Terraform refresh?

- Use the -refresh=false option with the terraform plan command.

This option will refer the state file not the actual infrastructure state. It will not update the state file.

### Terrafom -refresh-only

The terraform refresh command is used to update the state file.

If you ‘apply’ the plan generated by terraform plan -refresh-onlyusing terraform apply -refresh-only, it fixes the “terraform state file”, by reconciling the drift between the “actual infrastructure state” and the “terraform state file”.

### Terraform Remote State

Terraform remote state is used to store the state file in a remote location. It is defined using the backend block.

Example:

```hcl

terraform {
  backend "azurerm" {
    resource_group_name  = "example-resources"
    storage_account_name = "examplestorageaccount"
    container_name       = "tfstate"
    key                  = "prod.terraform.tfstate"
  }
}
```

Another example:

```hcl
terraform {
  backend "aws" {
    bucket         = "examplebucket"
    key            = "prod.terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "exampletable"
  }
}
```

## Terraform Commands

The following are the Terraform commands:

|Command|Description|
|---|---|
|terraform init|It is used to initialize the working directory.|
|terraform plan|It is used to create an execution plan.|
|terraform apply|It is used to apply the changes required to reach the desired state of the configuration.|
|terraform destroy|It is used to destroy the Terraform-managed infrastructure.|
|terraform fmt|It is used to rewrite Terraform configuration files to a canonical format and style.|
|terraform validate|It is used to validate the configuration files.|
|terraform taint|It is used to mark a resource for recreation.|
|terraform untaint|It is used to unmark a resource as tainted.|
|terraform import|It is used to import existing infrastructure into Terraform.|
|terraform workspace|It is used to create, change, and delete Terraform workspaces.|
|terraform output|It is used to read an output from a state file.|
|terraform providers|It is used to show the providers required for the configuration.|

### Terraform plan out file

If you want to save output of the terraform plan command in a file, then you can use the -out option.It will also save the value of the variables in the file.Once it is saved, you can use the terraform apply command to apply the changes. It will not ask for the value of the variables.You can also use the terraform show command to view the content of the file.

Example:

```hcl
terraform plan -var-file="variables.tfvars" -out="plan.plan"
```

## Mutable and Immutable Infrastructure

### Mutable Infrastructure

Mutable infrastructure is infrastructure that can be changed after it is created.

### Immutable Infrastructure

Immutable infrastructure is infrastructure that cannot be changed after it is created.

## Lifecycle Rules

Lifecycle rules are used to define the lifecycle of a resource. It is defined using the lifecycle block.

Below are the lifecycle rules:

|Lifecycle Rule|Description|
|---|---|
|prevent_destroy|It is used to prevent the resource from being destroyed.|
|ignore_changes|It is used to ignore the changes in the resource.|
|create_before_destroy|It is used to create a new resource before destroying the old resource.|

Example:

```hcl

resource "azurerm_resource_group" "example" {
  name     = "example-resources"
  location = "West Europe"

  lifecycle {
    prevent_destroy = true
  }
}
```

Another example:

```hcl

resource "azurerm_resource_group" "example" {
  name     = "example-resources"
  location = "West Europe"

  lifecycle {
    ignore_changes = [name]
  }
}
```

Another example:

```hcl

resource "azurerm_resource_group" "example" {
  name     = "example-resources"
  location = "West Europe"

  lifecycle {
    create_before_destroy = true
  }
}
```

## Data Source

A data source is used to get the information about the existing resources. It is defined using the data block.

Example:

```hcl

data "azurerm_resource_group" "example" {
  name = "example-resources"
}
```

## Terraform Import

Terraform import is used to import existing infrastructure into Terraform. It is used to import the existing resources into the Terraform state file.

Example:

```hcl

terraform import azurerm_resource_group.example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/example-resources
```

## Difference between Terraform Import,Data Source and Resource

|Terraform Import|Data Source|Resource|
|---|---|---|
|It is used to import the existing resources into the Terraform state file.|It is used to get the information about the existing resources.|It is used to create the new resources.|

## Meta-Arguments

Meta-arguments are used to define the behavior of the resource. It is defined using the meta-argument block.

Below are the meta-arguments:

|Meta-Argument|Description|
|---|---|
|depends_on|It is used to define the explicit dependency between the resources.|
|count|It is used to create multiple copies of the resource.|
|for_each|It is used to create multiple copies of the resource.|
|provider|It is used to define the provider for the resource.|
|lifecycle|It is used to define the lifecycle of the resource.|

### Terraform Count

Terraform count is used to create multiple copies of the resource. It is defined using the count meta-argument.

When using count, the value of the count argument must be a number. The number is used as the count value for the resulting resources.

For each count value, the corresponding resource is created with the count.index value as the index value.

Example:

```hcl

resource "azurerm_resource_group" "example" {
  count    = 3
  name     = "example-resources-${count.index}"
  location = "West Europe"
}
```

### Terraform For Each

Terraform for each is used to create multiple copies of the resource. It is defined using the for_each meta-argument.

When using for_each, the value of the for_each argument must be a map or set. The keys of the map or set are used as the index values for the resulting resources.

For each stored value, the corresponding resource is created with the key as the index value and the value as the value of the resource.

Example:

```hcl

resource "azurerm_resource_group" "example" {
  for_each = toset(["example-resources-1", "example-resources-2", "example-resources-3"])
  name     = each.key
  location = "West Europe"
}
```

## For Each vs Count

|For Each|Count|
|---|---|
|It is used to create multiple copies of the resource.|It is used to create multiple copies of the resource.|
|It is defined using the for_each meta-argument.|It is defined using the count meta-argument.|
|Set and map are the only supported types.|Number is the only supported type.|
|The keys of the map or set are used as the index values for the resulting resources.|The count value is used as the index value for the resulting resources.|
|The value of the resource is the value of the map.|The value of the resource is the count.index.|

## Provider

A provider is used to interact with the resources. It is defined using the provider block.

Example:

```hcl

provider "azurerm" {
  features {}
}
```

### Version Constraints in provider

Version constraints in provider are used to specify the version of the provider. It is defined using the version meta-argument.

Example:

```hcl

provider "azurerm" {
  version = "~> 2.0"
  features {}
}
```

|Type|Description|
|---|---|
|1.0|It is used to specify the exact version of the provider.|
|!= 1.0|It is used to specify the version of the provider that is not equal to the specified version.|
|<1.0|It is used to specify the version of the provider that is less than the specified version.|
|>1.0|It is used to specify the version of the provider that is greater than the specified version.|
|~>1.0|It is used to specify the version of the provider that is greater than or equal to the specified version.But it will not update the major version|

## Provisioner in Terraform

Provisioner in Terraform is used to execute the scripts on the remote machine. It is defined using the provisioner block.

Below are the provisioner in Terraform:

|Provisioner|Description|
|---|---|
|local-exec|It is used to execute the scripts on the local machine.|
|remote-exec|It is used to execute the scripts on the remote machine.|

local-exec Example:

```hcl

resource "azurerm_resource_group" "example" {
  name     = "example-resources"
  location = "West Europe"

  provisioner "local-exec" {
   inline = [
      "echo ${azurerm_resource_group.example.name}",
      "echo ${azurerm_resource_group.example.location}",
    ]
  }
}
```

remote-exec Example:

```hcl

resource "azurerm_resource_group" "example" {
  name     = "example-resources"
  location = "West Europe"

  provisioner "remote-exec" {
    inline = [
      "echo ${azurerm_resource_group.example.name}",
      "echo ${azurerm_resource_group.example.location}",
    ]
  }
  connection {
    type = "ssh"
    host = "example.com"
    user = "example"
    private_key = file("~/.ssh/id_rsa")
  }
}
```

## Terraform Taint

Terraform taint is used to mark the resource as tainted. It is used to force the recreation of the resource.

Example:

```hcl
terraform taint azurerm_resource_group.example
```

## Terraform Replace

Terraform replace is used to replace the resource. It is used to force the recreation of the resource.

Example:

```hcl
terraform replace azurerm_resource_group.example
```

## Terraform Taint vs Replace

|Terraform Taint|Terraform Replace|
|---|---|
|It is used to mark the resource as tainted.|It is used to replace the resource.|
|It is used to force the recreation of the resource.|It is used to force the recreation of the resource.|
|It is used to mark the resource as tainted.|It is used to replace the resource.|
|It is used to force the recreation of the resource.|It is used to force the recreation of the resource.|

## Debugging in Terraform

Debugging in Terraform is used to debug the Terraform code. It is defined using the TF_LOG and TF_LOG_PATH environment variables.

Example:

```hcl
export TF_LOG=TRACE
export TF_LOG_PATH=terraform.log
```

## Terraform Modules

Terraform modules are used to create reusable components. It is defined using the module block.

Uses of Terraform Modules:

- It is used to create reusable components.
- It is used to create multiple copies of the resource.
- You can use the Terraform Registry to find and use modules created by the community.
- You can create your own modules and publish them to the Terraform Registry.

Example:

```hcl

module "example" {
  source = "github.com/terraform-azure-modules/terraform-azurerm-resource-group"
  name   = "example-resources"
  location = "West Europe"
}
```

### How to create Terraform Modules

- Create a directory for the module.
- Create a main.tf file.
- Create a variables.tf file.
- Create a outputs.tf file.
- Create a README.md file.

Example:

```hcl

module "example" {
  source = "github.com/terraform-azure-modules/terraform-azurerm-resource-group"
  name   = "example-resources"
  location = "West Europe"
}
```

## Terraform Functions

Terraform functions are used to perform the operations on the values. It is defined using the function name.

We can classify the Terraform functions into four Important categories:

- Numeric Functions: max, min, ceil, floor, log, pow, sqrt, signum
- String Functions: lower, upper, title, substr, replace, trim, format, formatlist, join, split, lookup
- Collection Functions: length, keys, values, contains, distinct, chunklist, flatten, zipmap
- Type Conversion Functions: tolist, tomap, toset, tostring, tonumber

Following are the Terraform functions:

|Function|Description|Syntax|Sample Input|Sample Output|
|---|---|---|---|---|
|abs|It is used to return the absolute value of the number.|abs(number)|-1|1|
|abspath|It is used to return the absolute path of the file.|abspath(path)|"./example.txt"|"/home/user/example.txt"|
|basename|It is used to return the base name of the file.|basename(path)|"/home/user/example.txt"|example.txt|
|base64decode|It is used to return the base64 decoded string.|base64decode(string)|"SGVsbG8gVGVyZm9ybQ=="|Hello Terraform|
|base64encode|It is used to return the base64 encoded string.|base64encode(string)|"Hello Terraform"|SGVsbG8gVGVyZm9ybQ==|
|base64gzip|It is used to return the base64 encoded gzip
|binarydecode|It is used to return the binary decoded string.|binarydecode(string)|"0100100001100101011011000110110001101111"|Hello Terraform|
|binaryencode|It is used to return the binary encoded string.|binaryencode(string)|"Hello Terraform"|0100100001100101011011000110110001101111|
|ceil|It is used to return the ceiling value of the number.|ceil(number)|1.1|2|
|chomp|It is used to return the string without the trailing newline character.|chomp(string)|"Hello Terraform\n"|Hello Terraform|
|chunklist|It is used to return the list of chunks.|chunklist(list, chunk_size)|["a", "b", "c", "d", "e"], 2|[["a", "b"], ["c", "d"], ["e"]]|
|cidrhost|It is used to return the host address of the CIDR block.|cidrhost(cidrblock, hostnum)|"
|cidrnetmask|It is used to return the netmask address of the CIDR block.|cidrnetmask(cidrblock)|"
|cidrsubnet|It is used to return the subnet address of the CIDR block.|cidrsubnet(cidrblock, newbits, netnum)|"
|coalesce|It is used to return the first non-empty string.|coalesce(string1, string2, ...)|"Hello", "", "Terraform"|Hello|
|coalescelist|It is used to return the first non-empty list.|coalescelist(list1, list2, ...)|["a", "b"], [], ["c", "d"]|["a", "b"]|
|compact|It is used to return the list without the empty elements.|compact(list)|["a", "", "b"]|["a", "b"]|
|concat|It is used to return the concatenated list.|concat(list1, list2, ...)|["a", "b"], ["c", "d"]|["a", "b", "c", "d"]|
|contains|It is used to return true if the list contains the element.|contains(list, element)|["a", "b", "c"], "b"|true|
|dirname|It is used to return the directory name of the file.|dirname(path)|"/home/user/example.txt"|/home/user|
|distinct|It is used to return the list without the duplicate elements.|distinct(list)|["a", "b", "a"]|["a", "b"]|
|element|It is used to return the element of the list.|element(list, index)|["a", "b", "c"], 1|b|
|file|It is used to return the contents of the file.|file(path)|"./example.txt"|Hello Terraform|
|fileexists|It is used to return true if the file exists.|fileexists(path)|"./example.txt"|true|
|flatten|It is used to return the flattened list.|flatten(list)|[["a", "b"], ["c", "d"]]|["a", "b", "c", "d"]|
|floor|It is used to return the floor value of the number.|floor(number)|1.9|1|
|format|It is used to return the formatted string.|format(format, ...)|"%s %s", "Hello", "Terraform"|Hello Terraform|
| formatdate|It is used to return the formatted date.|formatdate(format, timestamp)|"2006-01-02", "2020-01-01T00:00:00Z"|2020-01-01|
|formatlist|It is used to return the formatted list.|formatlist(format, ...)|"%s %s", ["Hello", "Terraform"]|["Hello Terraform"]|
|indent|It is used to return the indented string.|indent(num_spaces, string)|2, "Hello Terraform"|  Hello Terraform|
|index|It is used to return the index of the element in the list.|index(list, element)|["a", "b", "c"], "b"|1|
|join|It is used to return the joined string.|join(separator, list)|",", ["a", "b", "c"]|a,b,c|
|jsonencode|It is used to return the JSON encoded string.|jsonencode(value)|["a", "b", "c"]|["a", "b", "c"]|
|keys|It is used to return the list of keys of the map.|keys(map)|{"a" = "b", "c" = "d"}|["a", "c"]|
|length|It is used to return the length of the list or map.|length(list or map)|["a", "b", "c"]|3|
|list|It is used to return the list of elements.|list(element1, element2, ...)|"a", "b", "c"|["a", "b", "c"]|
|log|It is used to return the natural logarithm of the number.|log(number)|10|2.302585092994046|
|lower|It is used to return the lower case string.|lower(string)|"Hello Terraform"|hello terraform|
|map|It is used to return the map of elements.|map(key1, value1, key2, value2, ...)|"a", "b", "c", "d"|{"a" = "b", "c" = "d"}|
|matchkeys|It is used to return the list of values for the given keys.|matchkeys(values, keys, searchset)|["a", "b", "c"], ["a", "c"], ["a", "b"]|["a", "c"]|
|max|It is used to return the maximum value of the list.|max(list)|[1, 2, 3]|3|
|md5|It is used to return the MD5 hash of the string.|md5(string)|"Hello Terraform"|aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d|
|merge|It is used to return the merged map.|merge(map1, map2, ...)|{"a" = "b"}, {"c" = "d"}|{"a" = "b", "c" = "d"}|
|min|It is used to return the minimum value of the list.|min(list)|[1, 2, 3]|1|
|pathexpand|It is used to return the expanded path.|pathexpand(path)|"~/example.txt"|/home/user/example.txt|
|pow|It is used to return the power of the number.|pow(number, exponent)|2, 3|8|
|range|It is used to return the list of numbers in the range.|range(start, stop, step)|1, 5, 2|[1, 3, 5]|
|regex|It is used to return the regular expression.|regex(regex, string)|"Hello (.*)", "Hello Terraform"|Terraform|
|regexall|It is used to return the list of all matches of the regular expression.|regexall(regex, string)|"Hello (.*)", "Hello Terraform"|["Terraform"]|
|replace|It is used to return the string with the replaced value.|replace(string, old, new, n)|"Hello Terraform", "Terraform", "World", 1|Hello World|

and so on.

## Conditional Expressions

Conditional expressions are used to evaluate the condition and return the result based on the condition. The conditional expressions are as follows:

## Terraform Workspace

Terraform workspace is used to create multiple workspaces for the same Terraform configuration. It is used to manage the state of the infrastructure. It is used to create multiple state.

### Terraform Workspace Commands

The Terraform workspace commands are as follows:

|Command|Description|
|:-|:-|
|terraform workspace new|It is used to create a new workspace.|
|terraform workspace select|It is used to select the workspace.|
|terraform workspace show|It is used to show the current workspace.|
|terraform workspace list|It is used to list the workspaces.|
|terraform workspace delete|It is used to delete the workspace.|
